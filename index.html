<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RPG Dialogue Sound Generator</title>
<meta name="description" content="Import your RPG dialogue audio samples, loop, pitch-shift, and generate variations effortlessly with the RPG Dialogue Sound Generator by MobMasterMind." />
<meta name="keywords" content="RPG dialogue, audio loop, pitch shift, sound generator, game audio, sound effects, MobMasterMind" />
<meta name="author" content="MobMasterMind" />
<style>
  @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');

  /* Root colors for orangy-pinkish gradient theme */
  :root {
    --color-primary-start: #f63763;
    --color-primary-end: #d98851;
    --color-bg: #fff0f0;
    --color-text: #4a1a1a;
    --color-input-bg: #ffe9e9;
    --color-input-border: #f68383;
    --color-button-bg: #f63763;
    --color-button-hover-bg: #d98851;
    --color-button-text: #fff;
    --color-status-text: #9c3a3a;
  }

  /* Smooth fade-in animation */
  @keyframes fadeInUp {
    0% {
      opacity: 0;
      transform: translateY(10px);
    }
    100% {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Body styling */
  body {
    font-family: 'Poppins', sans-serif;
    background: linear-gradient(135deg, var(--color-primary-start), var(--color-primary-end));
    color: var(--color-text);
    margin: 0; 
    padding: 20px;
    display: flex; 
    flex-direction: column; 
    align-items: center;
    min-height: 100vh;
    animation: fadeInUp 1s ease forwards;
  }

  /* Main container styling */
  main {
    background: var(--color-bg);
    padding: 25px 30px;
    border-radius: 18px;
    box-shadow: 0 12px 28px rgba(214, 84, 84, 0.35);
    max-width: 520px;
    width: 100%;
    animation: fadeInUp 1s ease forwards;
  }

  /* Heading styling */
  h1 {
    margin-bottom: 10px;
    font-weight: 700;
    font-size: 2rem;
    text-align: center;
    color: #7a1e1e;
    text-shadow: 0 2px 6px rgba(246, 55, 99, 0.8);
  }

  /* Labels */
  label {
    display: flex;
    align-items: center;
    margin-top: 18px;
    font-weight: 600;
    color: #7a1e1e;
    letter-spacing: 0.02em;
    gap: 6px;
  }

  /* Tooltip question mark */
  label .tooltip-icon {
    position: relative;
    display: inline-block;
    width: 16px;
    height: 16px;
    line-height: 16px;
    font-weight: 700;
    color: var(--color-button-bg);
    background: var(--color-input-bg);
    border: 2px solid var(--color-input-border);
    border-radius: 50%;
    text-align: center;
    font-size: 14px;
    cursor: help;
    user-select: none;
  }

  /* Tooltip text container */
  label .tooltip-icon::after {
    content: attr(data-tooltip);
    position: absolute;
    bottom: 125%;
    left: 50%;
    transform: translateX(-50%);
    width: max-content;
    max-width: 220px;
    background: #7a1e1e;
    color: #fff;
    padding: 6px 10px;
    border-radius: 8px;
    font-size: 0.8rem;
    font-weight: 400;
    white-space: normal;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
    z-index: 10;
  }

  /* Tooltip arrow */
  label .tooltip-icon::before {
    content: "";
    position: absolute;
    bottom: 115%;
    left: 50%;
    transform: translateX(-50%);
    border-width: 6px;
    border-style: solid;
    border-color: #7a1e1e transparent transparent transparent;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
    z-index: 10;
  }

  /* Show tooltip on hover */
  label .tooltip-icon:hover::after,
  label .tooltip-icon:hover::before {
    opacity: 1;
    pointer-events: auto;
  }

  /* Inputs and selects styling */
  input[type="file"],
  input[type="number"],
  select {
    width: 100%;
    padding: 10px 14px;
    margin-top: 8px;
    border: 2px solid var(--color-input-border);
    border-radius: 10px;
    font-size: 1rem;
    background: var(--color-input-bg);
    color: var(--color-text);
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
    vertical-align: middle;  /* Fix alignment */
  }

  input[type="file"]::-webkit-file-upload-button {
    background: var(--color-button-bg);
    border: none;
    padding: 6px 12px;
    border-radius: 8px;
    color: var(--color-button-text);
    font-weight: 600;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }

  input[type="file"]::-webkit-file-upload-button:hover {
    background: var(--color-button-hover-bg);
  }

  input[type="number"]:focus,
  select:focus {
    border-color: var(--color-button-hover-bg);
    box-shadow: 0 0 10px var(--color-button-hover-bg);
    outline: none;
  }

  /* Buttons styling */
  button {
    background: var(--color-button-bg);
    color: var(--color-button-text);
    font-weight: 700;
    padding: 12px 0;
    margin-top: 24px;
    width: 100%;
    border: none;
    border-radius: 14px;
    font-size: 1.15rem;
    cursor: pointer;
    box-shadow: 0 6px 15px rgba(246, 55, 99, 0.55);
    transition: background-color 0.4s ease, box-shadow 0.3s ease;
  }

  button:hover:not(:disabled) {
    background: var(--color-button-hover-bg);
    box-shadow: 0 8px 22px rgba(217, 136, 81, 0.75);
  }

  button:disabled {
    background: #fca9a9;
    cursor: not-allowed;
    box-shadow: none;
  }

  /* Button row for preview/stop */
  .btn-row {
    display: flex;
    gap: 16px;
    margin-top: 20px;
  }
  .btn-row button {
    flex: 1;
  }

  #stopPreviewBtn {
    background: #d94a4a;
    box-shadow: 0 6px 15px rgba(217, 74, 74, 0.75);
  }
  #stopPreviewBtn:hover:not(:disabled) {
    background: #b13737;
    box-shadow: 0 8px 22px rgba(179, 55, 55, 0.85);
  }

  /* Status text */
  #status {
    margin-top: 18px;
    min-height: 24px;
    font-weight: 700;
    color: var(--color-status-text);
    text-align: center;
    letter-spacing: 0.01em;
    font-size: 1rem;
    user-select: none;
  }

  /* Credit styling */
  footer {
    margin-top: 30px;
    font-size: 0.85rem;
    color: #6a2c2ccc;
    font-style: italic;
    user-select: none;
  }
  footer a {
    color: #d98851;
    text-decoration: none;
    font-weight: 600;
  }
  footer a:hover {
    text-decoration: underline;
  }
</style>
</head>
<body>
  <h1>RPG Dialogue Sound Generator</h1>
  <main>
    <label for="fileInput" data-tooltip="Import an audio file in wav, flac, ogg, or mp3 format.">
      Import Audio File (wav, flac, ogg, mp3)
      <span class="tooltip-icon" data-tooltip="Supported formats: wav, flac, ogg, mp3, or any audio.">?</span>
    </label>
    <input type="file" id="fileInput" accept=".wav,.flac,.ogg,.mp3,audio/*" />

    <label for="startTime" data-tooltip="Set the start time in seconds to cut the audio sample.">
      Cut Start Time (seconds)
      <span class="tooltip-icon" data-tooltip="Audio playback will begin from this time.">?</span>
    </label>
    <input type="number" id="startTime" min="0" step="0.01" value="0" disabled />

    <label for="endTime" data-tooltip="Set the end time in seconds to cut the audio sample.">
      Cut End Time (seconds)
      <span class="tooltip-icon" data-tooltip="Audio playback will end at this time.">?</span>
    </label>
    <input type="number" id="endTime" min="0" step="0.01" value="0" disabled />

    <label for="modeSelect" data-tooltip="Choose between loop export or generating pitch variations.">
      Mode
      <span class="tooltip-icon" data-tooltip="Loop Export: create a looping audio file. Generate Variations: create pitch-shifted samples in a ZIP.">?</span>
    </label>
    <select id="modeSelect" disabled>
      <option value="loop">Loop Export</option>
      <option value="variations">Generate Variations (ZIP)</option>
    </select>

    <div id="loopLengthContainer" style="display:none;">
      <label for="loopLength" data-tooltip="Specify the total desired length of the output loop in seconds.">
        Total Loop Length (seconds)
        <span class="tooltip-icon" data-tooltip="Controls how long the final looped audio will be.">?</span>
      </label>
      <input type="number" id="loopLength" min="0.1" step="0.1" value="5" />
    </div>

    <label for="loopDelay" data-tooltip="Set the delay between loops in milliseconds.">
      Loop Delay (milliseconds)
      <span class="tooltip-icon" data-tooltip="Time gap inserted between each loop iteration.">?</span>
    </label>
    <input type="number" id="loopDelay" min="0" step="1" value="50" />

    <label for="pitchVariation" data-tooltip="Set the pitch variation range in semitones.">
      Pitch Variation (± semitones)
      <span class="tooltip-icon" data-tooltip="Maximum pitch shift applied to loops or variations.">?</span>
    </label>
    <input type="number" id="pitchVariation" min="0" max="12" step="0.1" value="0.5" />

    <label for="randomPitch" data-tooltip="Choose whether to randomize pitch for each loop.">
      Randomize Pitch Each Loop
      <span class="tooltip-icon" data-tooltip="If yes, pitch will change randomly each loop; otherwise, it stays constant.">?</span>
    </label>
    <select id="randomPitch">
      <option value="true" selected>Yes</option>
      <option value="false">No (constant pitch shift)</option>
    </select>

    <div id="variationsCountContainer" style="display:none;">
      <label for="variationsCount" data-tooltip="Set how many pitch-shifted variations to generate.">
        Number of Variations
        <span class="tooltip-icon" data-tooltip="Controls how many variations will be included in the ZIP file.">?</span>
      </label>
      <input type="number" id="variationsCount" min="1" max="100" step="1" value="10" />
    </div>

    <div class="btn-row">
      <button id="previewBtn" disabled>Preview</button>
      <button id="stopPreviewBtn" disabled>Stop Preview</button>
    </div>

    <button id="generateBtn" disabled>Generate & Download</button>

    <div id="status"></div>
  </main>
  <footer>
    Created with care by <a href="https://github.com/MobMasterMind" target="_blank" rel="noopener noreferrer">MobMasterMind</a>
  </footer>

<script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.0/dist/jszip.min.js"></script>
<script>
let audioBuffer = null;
let audioContext = null;
let previewSource = null;

const fileInput = document.getElementById('fileInput');
const startTimeInput = document.getElementById('startTime');
const endTimeInput = document.getElementById('endTime');
const modeSelect = document.getElementById('modeSelect');
const loopLengthContainer = document.getElementById('loopLengthContainer');
const loopLengthInput = document.getElementById('loopLength');
const loopDelayInput = document.getElementById('loopDelay');
const pitchVariationInput = document.getElementById('pitchVariation');
const randomPitchSelect = document.getElementById('randomPitch');
const variationsCountContainer = document.getElementById('variationsCountContainer');
const variationsCountInput = document.getElementById('variationsCount');
const statusDiv = document.getElementById('status');
const previewBtn = document.getElementById('previewBtn');
const stopPreviewBtn = document.getElementById('stopPreviewBtn');
const generateBtn = document.getElementById('generateBtn');

fileInput.addEventListener('change', handleFileImport);
startTimeInput.addEventListener('change', validateCutTimes);
endTimeInput.addEventListener('change', validateCutTimes);
modeSelect.addEventListener('change', handleModeChange);
previewBtn.addEventListener('click', previewAudio);
stopPreviewBtn.addEventListener('click', stopPreview);
generateBtn.addEventListener('click', generateAndDownload);

function validateCutTimes() {
  if (!audioBuffer) return;
  let start = parseFloat(startTimeInput.value);
  let end = parseFloat(endTimeInput.value);

  if (isNaN(start) || start < 0) start = 0;
  if (isNaN(end) || end > audioBuffer.duration) end = audioBuffer.duration;

  if (start > end) start = end;

  startTimeInput.value = start.toFixed(2);
  endTimeInput.value = end.toFixed(2);
}

async function handleFileImport(e) {
  const file = e.target.files[0];
  if (!file) return;

  statusDiv.textContent = 'Loading audio...';
  const arrayBuffer = await file.arrayBuffer();
  if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();

  try {
    audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
    statusDiv.textContent = `Loaded: ${file.name} — Duration: ${audioBuffer.duration.toFixed(2)}s`;

    startTimeInput.disabled = false;
    endTimeInput.disabled = false;
    startTimeInput.value = '0.00';
    endTimeInput.value = audioBuffer.duration.toFixed(2);

    validateCutTimes();

    modeSelect.disabled = false;
    previewBtn.disabled = false;
    generateBtn.disabled = false;

    handleModeChange();
  } catch(err) {
    statusDiv.textContent = 'Error decoding audio file.';
    console.error(err);
    previewBtn.disabled = true;
    generateBtn.disabled = true;
    startTimeInput.disabled = true;
    endTimeInput.disabled = true;
    modeSelect.disabled = true;
  }
  stopPreviewBtn.disabled = true;
}

function handleModeChange() {
  const mode = modeSelect.value;
  if (mode === 'loop') {
    loopLengthContainer.style.display = 'block';
    variationsCountContainer.style.display = 'none';
  } else if (mode === 'variations') {
    loopLengthContainer.style.display = 'none';
    variationsCountContainer.style.display = 'block';
  }
}

function getRandomPitchSemitones(maxVariation) {
  return (Math.random() * 2 - 1) * maxVariation;
}

function semitonesToPlaybackRate(semitones) {
  return Math.pow(2, semitones / 12);
}

function createTrimmedBuffer(buffer, startSec, endSec) {
  const sampleRate = buffer.sampleRate;
  const channelCount = buffer.numberOfChannels;
  const startSample = Math.floor(startSec * sampleRate);
  const endSample = Math.floor(endSec * sampleRate);
  const frameCount = endSample - startSample;

  const trimmedBuffer = audioContext.createBuffer(channelCount, frameCount, sampleRate);

  for (let channel = 0; channel < channelCount; channel++) {
    const channelData = buffer.getChannelData(channel).subarray(startSample, endSample);
    trimmedBuffer.copyToChannel(channelData, channel, 0);
  }
  return trimmedBuffer;
}

function playBuffer(buffer, playbackRate = 1) {
  if (previewSource) {
    previewSource.stop();
    previewSource.disconnect();
    previewSource = null;
  }
  previewSource = audioContext.createBufferSource();
  previewSource.buffer = buffer;
  previewSource.playbackRate.value = playbackRate;
  previewSource.connect(audioContext.destination);
  previewSource.start();
  stopPreviewBtn.disabled = false;
  previewSource.onended = () => {
    stopPreviewBtn.disabled = true;
  };
}

function stopPreview() {
  if (previewSource) {
    previewSource.stop();
    previewSource.disconnect();
    previewSource = null;
    stopPreviewBtn.disabled = true;
  }
}

async function previewAudio() {
  if (!audioBuffer) return;
  const start = parseFloat(startTimeInput.value);
  const end = parseFloat(endTimeInput.value);
  if (start >= end) {
    statusDiv.textContent = 'Invalid cut times for preview.';
    return;
  }

  const mode = modeSelect.value;
  const trimmedBuffer = createTrimmedBuffer(audioBuffer, start, end);

  if (mode === 'loop') {
    const pitchVar = parseFloat(pitchVariationInput.value) || 0;
    const randomPitch = randomPitchSelect.value === 'true';

    let pitchSemitones = 0;
    if (pitchVar > 0) {
      pitchSemitones = randomPitch ? getRandomPitchSemitones(pitchVar) : pitchVar;
    }

    const playbackRate = semitonesToPlaybackRate(pitchSemitones);
    playBuffer(trimmedBuffer, playbackRate);
    statusDiv.textContent = `Preview playing (loop mode) with pitch shift ${pitchSemitones.toFixed(2)} semitones.`;
  } else {
    // Variations preview - just play original slice with no pitch shift
    playBuffer(trimmedBuffer, 1);
    statusDiv.textContent = 'Preview playing (variations mode).';
  }
}

function floatTo16BitPCM(output, offset, input) {
  for (let i = 0; i < input.length; i++, offset += 2) {
    let s = Math.max(-1, Math.min(1, input[i]));
    s = s < 0 ? s * 0x8000 : s * 0x7FFF;
    output.setInt16(offset, s, true);
  }
}

function encodeWAV(audioBuffer) {
  const numChannels = audioBuffer.numberOfChannels;
  const sampleRate = audioBuffer.sampleRate;
  const format = 1; // PCM
  const bitsPerSample = 16;
  const blockAlign = numChannels * bitsPerSample / 8;
  const byteRate = sampleRate * blockAlign;

  const length = audioBuffer.length * blockAlign + 44;
  const buffer = new ArrayBuffer(length);
  const view = new DataView(buffer);

  /* RIFF identifier */
  writeString(view, 0, 'RIFF');
  /* file length */
  view.setUint32(4, length - 8, true);
  /* RIFF type */
  writeString(view, 8, 'WAVE');
  /* format chunk identifier */
  writeString(view, 12, 'fmt ');
  /* format chunk length */
  view.setUint32(16, 16, true);
  /* sample format (raw) */
  view.setUint16(20, format, true);
  /* channel count */
  view.setUint16(22, numChannels, true);
  /* sample rate */
  view.setUint32(24, sampleRate, true);
  /* byte rate (sample rate * block align) */
  view.setUint32(28, byteRate, true);
  /* block align (channel count * bytes per sample) */
  view.setUint16(32, blockAlign, true);
  /* bits per sample */
  view.setUint16(34, bitsPerSample, true);
  /* data chunk identifier */
  writeString(view, 36, 'data');
  /* data chunk length */
  view.setUint32(40, audioBuffer.length * blockAlign, true);

  // Write PCM samples
  let offset = 44;
  for (let channel = 0; channel < numChannels; channel++) {
    const channelData = audioBuffer.getChannelData(channel);
    // Interleave channels here if stereo
  }
  // Interleave and write all channels sample data (16-bit PCM)
  const interleaved = interleaveChannels(audioBuffer);
  floatTo16BitPCM(view, 44, interleaved);

  return new Blob([view], { type: 'audio/wav' });
}

function writeString(view, offset, string) {
  for (let i = 0; i < string.length; i++) {
    view.setUint8(offset + i, string.charCodeAt(i));
  }
}

function interleaveChannels(buffer) {
  const length = buffer.length;
  const channels = buffer.numberOfChannels;
  const result = new Float32Array(length * channels);

  for (let i = 0; i < length; i++) {
    for (let ch = 0; ch < channels; ch++) {
      result[i * channels + ch] = buffer.getChannelData(ch)[i];
    }
  }
  return result;
}

function pitchShiftBuffer(buffer, semitones) {
  // For simplicity, this demo will just playback speed change.
  // Real pitch shifting without speed change requires complex DSP which is too big for here.
  // We return the original buffer and apply playbackRate when playing or exporting.
  return buffer;
}

async function generateAndDownload() {
  if (!audioBuffer) return;
  generateBtn.disabled = true;
  previewBtn.disabled = true;
  stopPreviewBtn.disabled = true;
  statusDiv.textContent = 'Generating audio... Please wait.';

  const start = parseFloat(startTimeInput.value);
  const end = parseFloat(endTimeInput.value);
  if (start >= end) {
    statusDiv.textContent = 'Invalid cut times.';
    generateBtn.disabled = false;
    previewBtn.disabled = false;
    return;
  }
  const mode = modeSelect.value;

  if (mode === 'loop') {
    const totalLoopLength = parseFloat(loopLengthInput.value) || 5;
    const loopDelayMS = parseInt(loopDelayInput.value) || 50;
    const pitchVar = parseFloat(pitchVariationInput.value) || 0;
    const randomPitch = randomPitchSelect.value === 'true';

    // Create trimmed buffer slice
    const trimmedBuffer = createTrimmedBuffer(audioBuffer, start, end);

    // We will create a new offline audio buffer with the looped audio + delay silence
    // We'll concatenate copies of trimmedBuffer with delay until reaching totalLoopLength

    // Calculate single loop duration + delay in seconds
    const delaySeconds = loopDelayMS / 1000;

    // Prepare array of buffers for offline rendering
    const loopDuration = trimmedBuffer.duration;
    const totalDuration = totalLoopLength;
    const loopsNeeded = Math.ceil(totalDuration / (loopDuration + delaySeconds));

    // Use OfflineAudioContext to render final looped audio with pitch and delay
    const sampleRate = trimmedBuffer.sampleRate;
    const channelCount = trimmedBuffer.numberOfChannels;
    const totalLengthSamples = Math.floor(totalDuration * sampleRate);

    const offlineCtx = new OfflineAudioContext(channelCount, totalLengthSamples, sampleRate);

    let currentOffset = 0;

    for (let i = 0; i < loopsNeeded; i++) {
      const source = offlineCtx.createBufferSource();
      source.buffer = trimmedBuffer;

      // Calculate pitch shift semitones for this loop
      let pitchSemitones = 0;
      if (pitchVar > 0) {
        pitchSemitones = randomPitch ? getRandomPitchSemitones(pitchVar) : pitchVar;
      }
      source.playbackRate.value = semitonesToPlaybackRate(pitchSemitones);

      source.connect(offlineCtx.destination);
      source.start(currentOffset);

      // Calculate duration after pitch change
      const adjustedDuration = trimmedBuffer.duration / source.playbackRate.value;
      currentOffset += adjustedDuration;

      // Add silence delay after loop (if not last)
      if (i < loopsNeeded - 1) {
        currentOffset += delaySeconds;
      }
    }

    const renderedBuffer = await offlineCtx.startRendering();

    // Encode to WAV
    const wavBlob = encodeWAV(renderedBuffer);

    const filename = `loop_${totalLoopLength.toFixed(2)}s_pitchVar${pitchVar}.wav`;
    downloadBlob(wavBlob, filename);
    statusDiv.textContent = `Generated loop WAV (${filename}) ready.`;
  } else if (mode === 'variations') {
    // Variations ZIP generation
    const count = parseInt(variationsCountInput.value) || 10;
    const pitchVar = parseFloat(pitchVariationInput.value) || 0;

    if (count < 1) {
      statusDiv.textContent = 'Invalid number of variations.';
      generateBtn.disabled = false;
      previewBtn.disabled = false;
      return;
    }

    const zip = new JSZip();

    for (let i = 0; i < count; i++) {
      // For each variation, get pitch semitones evenly spaced in range ±pitchVar
      const pitchSemitones = (count === 1) ? 0 : (i / (count - 1)) * 2 * pitchVar - pitchVar;

      const trimmedBuffer = createTrimmedBuffer(audioBuffer, start, end);

      // Offline context to pitch shift and export individual variation
      const sampleRate = trimmedBuffer.sampleRate;
      const channelCount = trimmedBuffer.numberOfChannels;
      const lengthSamples = trimmedBuffer.length;

      const offlineCtx = new OfflineAudioContext(channelCount, lengthSamples, sampleRate);
      const source = offlineCtx.createBufferSource();
      source.buffer = trimmedBuffer;
      source.playbackRate.value = semitonesToPlaybackRate(pitchSemitones);
      source.connect(offlineCtx.destination);
      source.start(0);

      const renderedBuffer = await offlineCtx.startRendering();

      const wavBlob = encodeWAV(renderedBuffer);
      zip.file(`variation_${i + 1}_pitch${pitchSemitones.toFixed(2)}.wav`, wavBlob);
      statusDiv.textContent = `Generating variation ${i + 1} of ${count}...`;
    }

    const zipBlob = await zip.generateAsync({ type: 'blob' });
    const filename = `variations_pitchVar${pitchVar}.zip`;
    downloadBlob(zipBlob, filename);
    statusDiv.textContent = `Generated ZIP with ${count} variations ready.`;
  }

  generateBtn.disabled = false;
  previewBtn.disabled = false;
}

function downloadBlob(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    URL.revokeObjectURL(url);
    a.remove();
  }, 100);
}
</script>
</body>
</html>
